/*

  MSE 2202 MSEBot Project
  Language: Arduino
  Authors: Group 16
  Date: current

  Rev 1 - Initial version
  Rev 2 - Update for MSEduino v. 2

*/


#include <Servo.h>
#include <EEPROM.h>
#include <uSTimer2.h>
#include <Wire.h>
#include <I2CEncoder.h>

Servo servo_leftMotor;
Servo servo_rightMotor;
Servo servo_slideMotor;
Servo servo_rollerMotor;  //might just connect it to power

I2CEncoder encoder_leftMotor;
I2CEncoder encoder_rightMotor;

//pins
const int frontLeftPing = 2;   //input plug or trig
const int frontLeftData = 3;   //output plug or echo
const int frontRightPing = 4;
const int frontRightData = 5;
const int leftPing = 10;
const int leftData = 11;
const int rightPing = 12;
const int rightData = 13;
const int leftMotor = 8;
const int rightMotor = 9;
const int slideMotor = 6;
const int motorEnableSwitch = 7;
const int leftBumper = A0;  //will also control mode
const int rightBumper = A1; //C to ground and NO to port
const int rightLightSensor = A2;
const int backLightSensor = A3;
const int ci_I2C_SDA = A4;         //I2C data = white
const int ci_I2C_SCL = A5;         //I2C clock = yellow

//constants
const int forwardSpeed = 1900; //set to max later (2100)
const int reverseSpeed = 1100; //set to max later (900)
const int forwardSlow = 1600;
const int reverseSlow = 1400;
const int brake = 1500;
const int straightTolerance = 10;
const int wallTolerance = 1000;
const int obstacleTolerance = 200;
const int wallAllowance = 1400;
const int beaconAllowance = 2500;
const int turnAllowance = 2000;
const int ninety = 550;
const int one80 = 2400;
const int three60 = 5200;
const int displayTime = 500;
const int slideRetracted = 0;
const int slideExtended = 1000;
const int motorCalibrationCycles = 3;
const int motorCalibrationTime = 5000;
const int leftMotorOffsetAddress_L = 12;
const int leftMotorOffsetAddress_H = 13;
const int rightMotorOffsetAddress_L = 14;
const int rightMotorOffsetAddress_H = 15;

//variables
long leftMotorPosition;
long rightMotorPosition;
unsigned long tempDistance;
unsigned long tempTimer = 0;
unsigned long chargeTimer = 0;
unsigned long frontLeftEcho;
unsigned long frontRightEcho;
unsigned long leftEcho;
unsigned long rightEcho;
unsigned long tempLeftEcho;
unsigned long tempRightEcho;
unsigned long threeSecondTimer = 0;
unsigned long tempDisplayTime;
unsigned long calibrationTime;
unsigned long leftMotorOffset;
unsigned long rightMotorOffset;
unsigned buttonHold = 0;
unsigned robotState = 0;
unsigned phaseA = 1; //overall logic
unsigned phaseB = 1; //finding the beacon
unsigned phaseC = 1; //avoiding obstacles
unsigned phaseD = 1; //
unsigned dumbCount = 0;
unsigned rightInfra; //right infrared sensor reading
unsigned backInfra;
unsigned leftMotorSpeed;
unsigned rightMotorSpeed;
unsigned calCount;
unsigned calCycle;
bool secondRound = false;
bool turnFlag;
bool obstacleFlag = false;
bool toggle = false;
bool worthFlag = false;
bool startingTurn;  //to sweep the other side on the second round
bool motorsEnabled = true;
bool bt_3sTimeUp = false;
bool bt_calInitialized = false;
byte b_lowByte;
byte b_highByte;


void setup() {
  Wire.begin();        // Wire library required for I2CEncoder library
  Serial.begin(9600);

  //set up ultrasonic sensors
  pinMode(frontLeftPing, OUTPUT);
  pinMode(frontLeftData, INPUT);
  pinMode(frontRightPing, OUTPUT);
  pinMode(frontRightData, INPUT);
  pinMode(leftPing, OUTPUT);
  pinMode(leftData, INPUT);
  pinMode(rightPing, OUTPUT);
  pinMode(rightData, INPUT);

  //set up motors
  pinMode(rightMotor, OUTPUT);
  servo_rightMotor.attach(rightMotor);
  pinMode(leftMotor, OUTPUT);
  servo_leftMotor.attach(leftMotor);
  pinMode(slideMotor, OUTPUT);
  servo_slideMotor.attach(slideMotor);
  /*pinMode(rollerMotor, OUTPUT);           likely unnecessary
    servo_rollerMotor.attach(rollerMotor);*/

  //set up bumper and mode button
  pinMode(leftBumper, INPUT_PULLUP);
  pinMode(rightBumper, INPUT_PULLUP);
  pinMode(motorEnableSwitch, INPUT);

  //set up encoders
  encoder_leftMotor.init(1.0 / 3.0 * MOTOR_393_SPEED_ROTATIONS, MOTOR_393_TIME_DELTA);
  encoder_leftMotor.setReversed(false);  // adjust for positive count when moving forward
  encoder_rightMotor.init(1.0 / 3.0 * MOTOR_393_SPEED_ROTATIONS, MOTOR_393_TIME_DELTA);
  encoder_rightMotor.setReversed(true);  // adjust for positive count when moving forward

  //read saved values from EEPROM
  b_lowByte = EEPROM.read(leftMotorOffsetAddress_L);
  b_highByte = EEPROM.read(leftMotorOffsetAddress_H);
  leftMotorOffset = word(b_highByte, b_lowByte);
  b_lowByte = EEPROM.read(rightMotorOffsetAddress_L);
  b_highByte = EEPROM.read(rightMotorOffsetAddress_H);
  rightMotorOffset = word(b_highByte, b_lowByte);
}


void loop() {
  if ((millis() - threeSecondTimer) >= 3000)
  {
    bt_3sTimeUp = true;
  }

  // button-based mode selection
  if ((digitalRead(leftBumper) == 0) && (toggle == false) && (robotState == 0))
  {
    tempTimer = millis();
    toggle = true;
  }
  if ((digitalRead(leftBumper) == 1) && (toggle == true) && (robotState == 0))
  {
    buttonHold = millis() - tempTimer;
    toggle = false;
    if (buttonHold < 2000) //tap to run or hold to callibrate
    {
      robotState = 1;
    }
    else
    {
      robotState = 2;
    }
  }

  // check if drive motors should be powered
  motorsEnabled = digitalRead(motorEnableSwitch);

  // modes
  // 0 = default after power up/reset
  // 1 = Press mode button once to enter. Run robot.
  // 2 = Press mode button four times to enter. Calibrate motor speeds to drive straight.
  switch (robotState)
  {
    case 0:    //default state
    frontRightEcho = ping(frontRightPing, frontRightData);
    Serial.println(frontRightEcho);
      leftEcho = ping(leftPing, leftData);
      rightEcho = ping(rightPing, rightData);
      servo_leftMotor.writeMicroseconds(brake);
      servo_rightMotor.writeMicroseconds(brake);
      servo_slideMotor.write(slideRetracted);
      encoder_leftMotor.zero();
      encoder_rightMotor.zero();
      if (leftEcho > rightEcho)    //to determine the first turn at the start of each round (assuming the robot is starting on the same side as the charging station)
      {
        turnFlag = false;
        startingTurn = false;
      }
      else
      {
        turnFlag = true;
        startingTurn = true;
      }
      break;

    case 1:    //run robot
      if (bt_3sTimeUp)
      {
        //set motor speeds
        leftMotorSpeed = constrain(forwardSpeed + leftMotorOffset, 1600, 2100);
        rightMotorSpeed = constrain(forwardSpeed + rightMotorOffset, 1600, 2100);
        if (millis() - chargeTimer == 60000 && phaseA == 1) //test to find how long it takes to reach the charging station
        {
          motorsEnabled = false;
          leftEcho = ping(leftPing, leftData);
          encoder_leftMotor.zero();
          encoder_rightMotor.zero();
          phaseA = 3;
        }
        //rightInfra = digitalRead(rightLightSensor);
        //Serial.println(rightInfra);       
        //Serial.println(turnFlag);
        switch (phaseA)
        {
          case 1:
            driveStraight();
            break;
          case 2:
            uTurn(turnFlag);
            break;
          case 3:
            findBeacon();
            break;
          case 4:
            obstacleAvoidance();
            break;
        }

        if (motorsEnabled == true)
        {
          servo_leftMotor.writeMicroseconds(leftMotorSpeed);
          servo_rightMotor.writeMicroseconds(rightMotorSpeed);
        }
        if (motorsEnabled == false)
        {
          servo_leftMotor.writeMicroseconds(brake);
          servo_rightMotor.writeMicroseconds(brake);
        }
      }
      break;

    case 2:    //calibrate motors
      if (bt_3sTimeUp)
      {
        if (!bt_calInitialized)
        {
          bt_calInitialized = true;
          encoder_leftMotor.zero();
          encoder_rightMotor.zero();
          calibrationTime = millis();
          servo_leftMotor.writeMicroseconds(forwardSpeed);
          servo_rightMotor.writeMicroseconds(forwardSpeed);
        }
        else if ((millis() - calibrationTime) > motorCalibrationTime)
        {
          servo_leftMotor.writeMicroseconds(brake);
          servo_rightMotor.writeMicroseconds(brake);
          leftMotorPosition = encoder_leftMotor.getRawPosition();
          rightMotorPosition = encoder_rightMotor.getRawPosition();
          if (leftMotorPosition > rightMotorPosition)
          {
            // May have to update this if different calibration time is used
            rightMotorOffset = 0;
            leftMotorOffset = (leftMotorPosition - rightMotorPosition) / 4;
          }
          else
          {
            // May have to update this if different calibration time is used
            rightMotorOffset = (rightMotorPosition - leftMotorPosition) / 4;
            leftMotorOffset = 0;
          }
          EEPROM.write(rightMotorOffsetAddress_L, lowByte(rightMotorOffset));
          EEPROM.write(rightMotorOffsetAddress_H, highByte(rightMotorOffset));
          EEPROM.write(leftMotorOffsetAddress_L, lowByte(leftMotorOffset));
          EEPROM.write(leftMotorOffsetAddress_H, highByte(leftMotorOffset));
          robotState = 0;    //go back to Mode 0
        }
      }
      break;
  }
  if ((millis() - tempDisplayTime) > displayTime)
  {
    tempDisplayTime = millis();
  }
}


unsigned long ping(const int p, const int d)
{
  digitalWrite(p, HIGH);
  delayMicroseconds(10);  //The 10 microsecond pause where the pulse in "high"
  digitalWrite(p, LOW);
  return pulseIn(d, HIGH, 10000);
}


void driveStraight() {
  frontLeftEcho = ping(frontLeftPing, frontLeftData);
  frontRightEcho = ping(frontRightPing, frontRightData);
  if ((frontLeftEcho <= wallAllowance) && (frontRightEcho <= wallAllowance))  //wall was reached
  {
    leftEcho = ping(leftPing, leftData);
    rightEcho = ping(rightPing, rightData);
    motorsEnabled = false;
    if (((turnFlag == false) && (leftEcho < turnAllowance)) || (turnFlag == true && rightEcho < turnAllowance))  //check if there is space for a u-turn
    {
      obstacleFlag = true;
      phaseC = 4;
    }
    dumbCount++;
  }
  /*if (((frontLeftEcho <= wallAllowance) && (frontRightEcho >= (wallAllowance + obstacleTolerance))) ||
      ((frontLeftEcho <= (wallAllowance + obstacleTolerance)) && (frontRightEcho >= wallAllowance))) //obstacle was reached
    {
    obstacleFlag = true;
    leftEcho = ping(leftPing, leftData);
    rightEcho = ping(rightPing, rightData);
    motorsEnabled = false;
    dumbCount++;
    if (((turnFlag == false) && (leftEcho < turnAllowance)) || ((turnFlag == true) && (rightEcho < turnAllowance)))  //check if there is another obstacle before turning
    {
      phaseC = 4;
    }
    }*/
  if (dumbCount >= 100)
  {
    encoder_leftMotor.zero();
    encoder_rightMotor.zero();
    dumbCount = 0;
    if (obstacleFlag == true)
    {
      phaseA = 4;
    }
    else
    {
      phaseA = 2;
    }
  }
  else  //correct if not straight
  {
    if (encoder_leftMotor.getRawPosition() - encoder_rightMotor.getRawPosition() >= straightTolerance) //left motor is ahead
    {
      leftMotorSpeed = brake;
      rightMotorSpeed = forwardSpeed;
    }
    if (encoder_rightMotor.getRawPosition() - encoder_leftMotor.getRawPosition() >= straightTolerance) //right motor is ahead
    {
      leftMotorSpeed = forwardSpeed;
      rightMotorSpeed = brake;
    }
    else
    {
      leftMotorSpeed = forwardSpeed;
      rightMotorSpeed = forwardSpeed;
    }
    motorsEnabled = true;
  }
}

void uTurn(bool direction) {
  if (direction == false)  //left turn
  {
    leftMotorSpeed = brake;
    rightMotorSpeed = forwardSpeed;
    motorsEnabled = true;
    if (encoder_rightMotor.getRawPosition() >= one80)
    {
      turnFlag = true;
      encoder_leftMotor.zero();
      encoder_rightMotor.zero();
      phaseA = 1;
    }
  }
  else  //right turn
  {
    leftMotorSpeed = forwardSpeed;
    rightMotorSpeed = brake;
    motorsEnabled = true;
    if (encoder_leftMotor.getRawPosition() >= one80)
    {
      turnFlag = false;
      encoder_leftMotor.zero();
      encoder_rightMotor.zero();
      if (phaseB == 3)
      {
        phaseB = 2;
      }
      else
      {
        phaseA = 1;
      }
    }
  }
}


void findBeacon() { //follow the perimeter of the room
  switch (phaseB)
  {
    case 1: //rotate 90 degrees counter-clockwise
      if (encoder_rightMotor.getRawPosition() >= ninety)
      {
        motorsEnabled = false;
        phaseB = 2;
      }
      else
      {
        leftMotorSpeed = reverseSpeed;
        rightMotorSpeed = forwardSpeed;
        motorsEnabled = true;
      }
      break;
    case 2: //check if the right IR sensor finds the beacon
      frontLeftEcho = ping(frontLeftPing, frontLeftData);
      frontRightEcho = ping(frontRightPing, frontRightData);
      rightEcho = ping(rightPing, rightData);
      rightInfra = digitalRead(rightLightSensor);
      if ((frontLeftEcho <= beaconAllowance) || (frontRightEcho <= beaconAllowance))
      {
        motorsEnabled = false;
        dumbCount++;
      }
      if (dumbCount > 50)
      {
        encoder_leftMotor.zero();
        encoder_rightMotor.zero();
        dumbCount = 0;
        phaseB = 1;
      }
      /*if (rightEcho >= (beaconAllowance + wallTolerance)) //check if worth turning right
        {
        if (worthFlag == false)
        {
          worthFlag = true;
          tempTimer = millis();
        }
        if (worthFlag == true && (millis() - tempTimer) >= 1000)
        {
          encoder_leftMotor.zero();
          encoder_rightMotor.zero();
          phaseB = 3;
        }
        }*/
      if ((rightInfra == 0) || (analogRead(rightLightSensor) < 500)) //beacon was found
      {
        motorsEnabled = false;
        phaseB = 4;
      }
      else
      {
        leftMotorSpeed = forwardSpeed;
        rightMotorSpeed = forwardSpeed;
        motorsEnabled = true;
      }
      break;
    case 3:
      if (encoder_leftMotor.getRawPosition() >= ninety)
      {
        motorsEnabled = false;
        phaseB = 2;
      }
      else
      {
        leftMotorSpeed = forwardSpeed;
        rightMotorSpeed = brake;
        motorsEnabled = true;
        worthFlag = false;
      }
      break;
    case 4: //rotate until the back IR sensor finds the beacon
      backInfra = digitalRead(backLightSensor);
      if ((backInfra == 0) || (analogRead(backLightSensor) < 500))
      {
        motorsEnabled = false;
        phaseB = 5;
      }
      else
      {
        leftMotorSpeed = reverseSpeed;
        rightMotorSpeed = forwardSpeed;
        motorsEnabled = true;
      }
      break;
    case 5: //move towards beacon
      if ((digitalRead(leftBumper) == 0) && (digitalRead(rightBumper) == 0)) //both bumpers were pressed
      {
        motorsEnabled = false;
        tempTimer = millis();
        phaseB = 6;
      }
      else
      {
        if (digitalRead(leftBumper) == 0) //only left bumper was pressed
        {
          leftMotorSpeed = brake;
          rightMotorSpeed = reverseSlow;
        }
        if (digitalRead(rightBumper) == 0)  //only right bumper was pressed
        {
          leftMotorSpeed = reverseSlow;
          rightMotorSpeed = brake;
        }
        else
        {
          leftMotorSpeed = reverseSpeed;
          rightMotorSpeed = reverseSpeed;
        }
        motorsEnabled = true;
      }
      break;
    case 6:
      servo_slideMotor.write(slideExtended);
      if (millis() - tempTimer >= 5000) //allow time for the slide to raise and the parts to fall
      {
        servo_slideMotor.write(slideRetracted);
        if (secondRound == false)
        {
          turnFlag = startingTurn;
          secondRound = true;
          phaseB = 1;
          phaseA = 1;
        }
      }
      break;
  }
}


void obstacleAvoidance() {
  switch (phaseC)
  {
    case 1:
      if (turnFlag == false)  //left turn on the spot
      {
        leftMotorSpeed = reverseSpeed;
        rightMotorSpeed = forwardSpeed;
        motorsEnabled = true;
        if (encoder_rightMotor.getRawPosition() >= ninety)
        {
          motorsEnabled = false;
          encoder_leftMotor.zero();
          encoder_rightMotor.zero();
          phaseC = 2;
        }
      }
      else  //turn right on the spot
      {
        leftMotorSpeed = forwardSpeed;
        rightMotorSpeed = reverseSpeed;
        motorsEnabled = true;
        if (encoder_leftMotor.getRawPosition() >= ninety)
        {
          motorsEnabled = false;
          encoder_leftMotor.zero();
          encoder_rightMotor.zero();
          phaseC = 2;
        }
      }
      break;
    case 2: //drive forward a bit
      leftMotorSpeed = forwardSpeed;
      rightMotorSpeed = forwardSpeed;
      motorsEnabled = true;
      if (encoder_leftMotor.getRawPosition() >= ninety)
      {
        motorsEnabled = false;
        leftEcho = ping(leftPing, leftData);
        rightEcho = ping(rightPing, rightData);
        encoder_leftMotor.zero();
        encoder_rightMotor.zero();
        phaseC = 3;
      }
      break;
    case 3: //turn towards the side with the greater distance
      if (turnFlag == false)
      {
        if (leftEcho < rightEcho)
        {
          leftMotorSpeed = forwardSpeed;
          rightMotorSpeed = reverseSpeed;
        }
        else
        {
          leftMotorSpeed = reverseSpeed;
          rightMotorSpeed = forwardSpeed;
          turnFlag = true;  //a u-turn has just been performed
        }
        motorsEnabled = true;
      }
      if (turnFlag == true)
      {
        if (leftEcho > rightEcho)
        {
          leftMotorSpeed = reverseSpeed;
          rightMotorSpeed = forwardSpeed;
        }
        else
        {
          leftMotorSpeed = forwardSpeed;
          rightMotorSpeed = reverseSpeed;
          turnFlag = false;  //a u-turn has just been performed
        }
        motorsEnabled = true;
      }
      if (encoder_leftMotor.getRawPosition() >= ninety || encoder_rightMotor.getRawPosition() >= ninety)
      {
        obstacleFlag = false;
        motorsEnabled = false;
        phaseC = 1;
        phaseA = 1;
      }
      break;
    case 4: //wall was reached and there is no space for a u-turn so reverse until there is space
      leftEcho = ping(leftPing, leftData);
      rightEcho = ping(rightPing, rightData);
      if (turnFlag == false)
      {
        if (leftEcho < turnAllowance)
        {
          leftMotorSpeed = reverseSpeed;
          rightMotorSpeed = reverseSpeed;
          motorsEnabled = true;
        }
        else
        {
          motorsEnabled = false;
          encoder_leftMotor.zero();
          encoder_rightMotor.zero();
          phaseC = 1;
        }
      }
      else
      {
        if (rightEcho < turnAllowance)
        {
          leftMotorSpeed = reverseSpeed;
          rightMotorSpeed = reverseSpeed;
          motorsEnabled = true;
        }
        else
        {
          motorsEnabled = false;
          encoder_leftMotor.zero();
          encoder_rightMotor.zero();
          phaseC = 1;
        }
      }
      break;
  }
}
