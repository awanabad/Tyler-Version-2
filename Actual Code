//additional libraries
//" "


//dynamic variables
unsigned long tempTimer = 0;
unsigned long chargeTimer = 0;
unsigned long angleKeeper = 0;
unsigned long distanceKeeper = 0;
bool turnFlag = false; //assuming the first u-turn is left, false will be a left turn and vice versa
bool chargeFlag = false; //to reverse when dropping off parts
bool foundBeacon = false; 
unsigned int phaseA = 1; //sweeping
unsigned int phaseB = 1; //dumping
unsigned int phaseC = 1; //resuming
unsigned echo; //ultrasonic sensor
const int forwardSpeed = 1800;
const int reverseSpeed = 1300;
const int forwardSlow = 1600;
const int reverseSlow = 1400;
const int brake = 1500;


void setup() 
{

}


void loop()
{
  if (echo <= 700 && chargeTimer < 7500) {phaseA = 2}; //test to find perfect distance from wall
  if (millis() - chargeTimer >= 7500) {phaseA = 3}; //test to find how long it takes to reach the charging station
  
  switch (phaseA)
  {
    case 1: 
      ping();
      driveStraight(chargeFlag);
      tempTimer = millis(); //use if we are basing the turns on time
      break;
    case 2:      
      uTurn(turnFlag);
      if (millis - tempTimer >= 1900) {phaseA = 1}; //set phaseA back to 1 after turning
      break;
    case 3:
      chargeFlag = true;
      findBeacon;
      break();
    case 4:
      resumeSweep();
      break;
  }
}


void driveStraight(bool direction)
{
  if (direction == false)
  {
    //set both motors to forwardSpeed
  }
  else
  {
    //set both motors to reverseSpeed
  }
}


void uTurn(bool direction)
{
  if (direction == false)
  {
    //left turn: set right motor to forwardSpeed and left to brake
  }
  else
  {
    //right turn: set left motor to forwardSpeed and right to brake
  }
}


void ping() //measure distance from wall
{
  //update echo
}


void findBeacon() // keep rotating on the spot until the beacon is found
{
  if (echo <= 600 && foundBeacon == true) {phaseB = 3}; //test to find perfect distance from beacon

  switch(phaseB)
  {
    case 1:
      //set left motor to forwardSlow
      //set right motor to reverseSlow
      angleKeeper = millis(); //record rotation time
      //if beacon is found,  foundBeacon = true and phaseB = 2
      break;
    case 2:
      ping();
      distancekeeper = millis(); //record traverse time
      driveStraight(chargeFlag);
      break;
    case 3:
      //set both motors to brake
      //dump parts off and reset
      phaseA = 4;
      phaseB = 1;
      chargeFlag = false;
      chargeTimer = millis();
      tempTimer = millis();
      break;
  }
}
 
 
void resumeSweep()
{
  switch (phaseC)
  {
    case 1:
      driveStraight(chargeFlag);
      if (millis - timer >= distanceKeeper) {phaseC = 2};
      break;
    case 2: // must rotate opposite to findBeacon: case 2
      //set left motor to reverseSlow
      //set right motor to forwardSlow
      if (millis - timer >= angleKeeper) {phaseA = 1};
  }
}
